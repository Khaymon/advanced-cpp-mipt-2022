1. При наследовании объекты и методы потомков в памяти идут после объектов и методов предка. При множественном наследовании объекты и методы предков располагаются в порядке, в каком они наследуются. Поэтому, возможно повторное наследование объектов и методов базового класса, от которых наследуются предки, что приводит к "Diamond Problem"
2. Виртуальное наследование используется, чтобы предотвратить "Diamond problem". В этом случае базовый класс является общим для двух предков. Сначала идет класс, который указан первым вместе с виртуальной таблицей, потом второй класс вместе с виртуальной таблицей, потом класс-потомок, потом базовый класс. При множественном виртуальном наследовании появляется две виртуальные таблицы в памяти, замедляется доступ к членам базового класса.
3. При обычном наследовании указатель на класс-потомок "обрезается" до указателя на класс-предок. При множественном, если приводим указатель к классу, который указан первым, происходит то же самое, что и с одиночным наследованием. Если приводим к классу, который указан вторым, происходит сдвиг указателя на размер первого класса. При ромбовидном наследовании, приведение напрямую к базовому классу вызывает неоднозначность. При виртуальном наследовании этой неоднозначности не возникает: указатель сдвигается на размеры классов, от которых происходит наследование и самого класса-наследника.
4.
first // конструктор базового класса вызывается первым
third // конструктор класса-наследника вызывается вторым
result = (14 ; 3) // так как g -- виртуальная, то вызывается B::g, так как h не виртуальная, то вызывается A::h. В случае c b вызываются все функции из B::
fourth // деструктор наследника вызывается первым
second // деструктор базового класса вызывается вторым
5. Файл prism.cpp